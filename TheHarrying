using System.Collections.Generic;
using UnityEngine;

public class AStar : MonoBehaviour 
{
    public static List<Hexagon> GetNeighbors(Hexagon hexagon, bool isOffsetRight = true)
    {
        return hexagon.GetNeighbors(isOffsetRight);
    }

    public static List<Hexagon> FindPath(HexagonGrid hexGrid, Character character, Hexagon end, bool isOffsetRight = true)
    {
        Hexagon start = character.GetCurrentHexagon();
        if (start == null)
        {
            Debug.LogError("Start hexagon cannot be null.");
            return null;
        }
        List<Hexagon> path = new List<Hexagon>();
        List<Hexagon> openList = new List<Hexagon>();
        HashSet<Hexagon> closedList = new HashSet<Hexagon>();

        Dictionary<Hexagon, float> gScore = new Dictionary<Hexagon, float>();
        Dictionary<Hexagon, float> fScore = new Dictionary<Hexagon, float>();

        Dictionary<Hexagon, Hexagon> cameFrom = new Dictionary<Hexagon, Hexagon>();

        gScore[start] = 0f;
        fScore[start] = GetHeuristicCost(start, end);

        openList.Add(start);

        while (openList.Count > 0)
        {
            Hexagon current = GetLowestFScore(openList, fScore);
            if (current == end)
            {
                return ReconstructPath(cameFrom, end);
            }

            openList.Remove(current);
            closedList.Add(current);

            foreach (Hexagon neighbor in current.GetNeighbors(isOffsetRight))
            {
                if (closedList.Contains(neighbor))
                {
                    continue;
                }

                float tentativeGScore = gScore[current] + GetMovementCost(current, neighbor);

                if (!openList.Contains(neighbor) || tentativeGScore < gScore[neighbor])
                {
                    cameFrom[neighbor] = current;
                    gScore[neighbor] = tentativeGScore;
                    fScore[neighbor] = tentativeGScore + GetHeuristicCost(neighbor, end);

                    if (!openList.Contains(neighbor))
                    {
                        openList.Add(neighbor);
                    }
                }
            }
        }

        return null;
    }

    private static List<Hexagon> ReconstructPath(Dictionary<Hexagon, Hexagon> cameFrom, Hexagon current)
    {
        List<Hexagon> path = new List<Hexagon>();

        while (cameFrom.ContainsKey(current))
        {
            path.Add(current);
            current = cameFrom[current];
        }

        path.Reverse();

        return path;
    }

    private static Hexagon GetLowestFScore(List<Hexagon> openList, Dictionary<Hexagon, float> fScore)
    {
        float lowestFScore = Mathf.Infinity;
        Hexagon lowestFScoreHex = null;

        foreach (Hexagon hex in openList)
        {
            if (fScore.ContainsKey(hex) && fScore[hex] < lowestFScore)
            {
                lowestFScore = fScore[hex];
                lowestFScoreHex = hex;
            }
        }

        return lowestFScoreHex;
    }
    public static float GetEstimatedCost(Hexagon start, Hexagon end)
    {
        // Get the distance between the two hexagons.
        float distance = Hexagon.Distance(start, end);

        // Return the estimated cost of the path.
        return distance;
    }
    private static float GetHeuristicCost(Hexagon start, Hexagon end)
    {
        return Hexagon.Distance(start, end);
    }

    public static float GetMovementCost(Hexagon current, Hexagon neighbor)
    {
        return Hexagon.Distance(current, neighbor);
    }
}
....
using UnityEngine;

public class PACM : MonoBehaviour
{
    public float movementSpeed = 5f;

    private Vector3 targetPosition;
    public int currentActionPoints;
    public int maxActionPoints = 10;
    private int lastActionPoints;


    private Hexagon currentHexagon;
    public Character character;

    private TurnManager turnManager;
    private Character characterName;

    private void Start()
    {
        currentActionPoints = maxActionPoints;
        targetPosition = transform.position;
        character = GetComponent<Character>();
        turnManager = FindObjectOfType<TurnManager>();
    }

    private void Update()
    {
        // Check if this character is the active character from the TurnManager
        if (character == turnManager.GetCurrentCharacter())
        {
            if (Input.GetMouseButtonDown(0))
            {
                RaycastHit hit;
                Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);

                if (Physics.Raycast(ray, out hit))
                {
                    // Get the hexagon that was hit by the raycast
                    Hexagon hexagon = GetHexagonFromRaycastHit(hit);

                    if (hexagon != null)
                    {
                        // Check if the current character has any action points left

                        {
                            // Check if the hexagon is walkable
                            if (hexagon.isWalkable)
                            {
                                // Check if the current character is already moving


                                // Move to the center of the hexagon
                                targetPosition = hexagon.transform.position;
                                currentHexagon = hexagon;

                                // Start moving towards the target position


                                // Set character isMoving flag to true



                            }
                        }
                    }
                }
            }
            {


                // Move towards the target position
                transform.position = Vector3.MoveTowards(transform.position, targetPosition, movementSpeed * Time.deltaTime);

                // Stop moving when the target position is reached
             



            }


        }
        if (lastActionPoints != currentActionPoints)
        {
            Debug.Log("Player " + characterName + " has " + currentActionPoints + " action points remaining.");
            lastActionPoints = currentActionPoints;
        }
    }


    private Hexagon GetHexagonFromRaycastHit(RaycastHit hit)
    {
        // Get the hexagon component from the object that was hit by the raycast
        Hexagon hexagon = hit.collider.GetComponent<Hexagon>();

        // If the object has a parent, get the hexagon component from the parent object
        if (hexagon == null && hit.collider.transform.parent != null)
        {
            hexagon = hit.collider.transform.parent.GetComponent<Hexagon>();
        }

        return hexagon;
    }
}
....
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Character : MonoBehaviour
{
    public int maxActionPoints = 10;
    public int currentActionPoints;

    public int agility;
    public int armorWeight;

    public string characterName;
    public int initiative;
    public Hexagon currentHex;
    private int lastActionPoints;
    public HexagonGrid hexagonGrid;
    public bool isCurrentTurn;
    public int currentIndex;
    public bool isMoving = false;

    public bool Moving
    {
        get
        {
            return isMoving;
        }
    }

    public bool NotMoving
    {
        get
        {
            return !isMoving;
        }
    }

    private void Start()
    {
        currentActionPoints = maxActionPoints;
        hexagonGrid = FindObjectOfType<HexagonGrid>();
        if (hexagonGrid == null)
        {
            Debug.LogError("Could not find HexagonGrid instance!");
        }
        else
        {
            Debug.Log("Found HexagonGrid instance!");
            currentHex = hexagonGrid.GetHexagonAt(transform.position);
        }
    }

    private void Update()
    {
        if (hexagonGrid == null)
        {
            return;
        }
        currentHex = hexagonGrid.GetHexagonAt(transform.position);

        if (lastActionPoints != currentActionPoints)
        {
            Debug.Log("Player " + characterName + " has " + currentActionPoints + " action points remaining.");
            lastActionPoints = currentActionPoints;
        }

        // Check if character has reached destination hexagon
        if (isMoving && currentHex != null && transform.position == currentHex.position)
        {
            isMoving = false;
        }
    }

    public IEnumerator MoveToHexagon(Hexagon hexagon)
    {
        if (isMoving)
        {
            Debug.LogWarning(name + " is already moving!");
            yield break;
        }

        Debug.Log("Moving " + name + " to hexagon " + hexagon.Index);
        if (currentHex != null)
        {
            currentHex.character = null;
        }
        hexagon.character = this;
        float distance = (hexagon.position - transform.position).magnitude;

        isMoving = true; // set isMoving to true at the beginning

        while (currentActionPoints >= distance)
        {
            const float moveSpeed = 5f;
            transform.position = Vector3.MoveTowards(transform.position, hexagon.position, moveSpeed * Time.deltaTime);
            if (transform.position == hexagon.position)
            {
                currentActionPoints -= (int)distance;
                Debug.Log(name + " moved to hexagon " + hexagon.Index + ". " + currentActionPoints + " action points remaining.");
                Debug.Log(name + " moved " + (int)distance + " hexagons. " + currentActionPoints + " action points remaining.");

                // update distance and check if there's enough action points for another move
                distance = (hexagon.position - transform.position).magnitude;
                if (currentActionPoints < distance)
                {
                    Debug.Log(name + " ran out of action points.");
                    break;
                }
            }
            yield return null;
        }

        isMoving = false; // set isMoving to false after finishing the loop


        // Check if character has run out of action points
        if (currentActionPoints <= 0)
        {
            Debug.Log(name + " ran out of action points.");
        }

        if (currentActionPoints > 0)
        {
            transform.position = Vector3.MoveTowards(transform.position, hexagon.position, currentActionPoints * Time.deltaTime);
            Debug.Log(name + " moved towards hexagon " + hexagon.Index + " but ran out of action points.");
            currentActionPoints = 0;
        }
        currentHex = hexagon;

        // Call MoveCurrentCharacterToHexagon method in TurnManager script
        TurnManager turnManager = FindObjectOfType<TurnManager>();
        if (turnManager != null)
        {
            turnManager.MoveCurrentCharacterToHexagon(hexagon);
        }

        Debug.Log("Moved " + characterName + " to hexagon " + currentHex.Index);
    }




    public void CalculateInitiative()
    {
        float baseInitiative = Random.Range(5f, 10f) / armorWeight;
        initiative = Mathf.RoundToInt(baseInitiative * agility);
    }




    public void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Player"))
        {
            Character player = other.GetComponent<Character>();
            if (player != null)
            {
                currentHex = player.GetCurrentHexagon();
            }
        }
    }

    public Hexagon GetCurrentHexagon()
    {
        if (hexagonGrid == null)
        {
            return null;
        }
        currentHex = hexagonGrid.GetHexagonAt(transform.position);

        // Find player based on tag "Player"
        GameObject playerObject = GameObject.FindGameObjectWithTag("Player");
        if (playerObject != null)
        {
            Character playerCharacter = playerObject.GetComponent<Character>();
            if (playerCharacter != null)
            {
                Debug.Log("Found player " + playerCharacter.characterName);
            }
        }

        return currentHex;
    }

    public void SetCurrentActionPoints(int points)
    {
        currentActionPoints = points;
    }

    public void SetLastActionPoints(int points)
    {
        lastActionPoints = points;
    }

    public void ResetActionPoints()
    {
        currentActionPoints = maxActionPoints;
        lastActionPoints = maxActionPoints;
    }

    public void UseActionPoints(int points)
    {
        currentActionPoints -= points;
        Debug.Log(name + " used " + points + " action points. " + currentActionPoints + " action points remaining.");
    }
}
....
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Hexagon : MonoBehaviour
{
    public Vector3 position { get; set; }
    public bool isWalkable { get; set; }
    public int x { get; set; }
    public int z { get; set; }
    public float y = 0f;

    public float size = 1.0f;
    public Character character { get; set; }
    public List<Hexagon> neighbors { get; set; } = new List<Hexagon>();

    public int Index
    {
        get { return x + z * HexagonGrid.Instance.gridSizeX; }
    }

    public Hexagon()
    {
        this.position = Vector3.zero;
        this.isWalkable = true;
        this.neighbors = new List<Hexagon>();
    }

    public Hexagon(Vector3 position, bool isWalkable, int x, int z)
    {
        this.position = position;
        this.isWalkable = isWalkable;
        this.x = x;
        this.z = z;
        this.neighbors = new List<Hexagon>();
    }

    public void AddNeighbor(Hexagon neighbor)
    {
        this.neighbors.Add(neighbor);
    }

    public static float Distance(Hexagon a, Hexagon b)
    {
        int dX = Mathf.Abs(a.x - b.x);
        int dZ = Mathf.Abs(a.z - b.z);

        return Mathf.Max(dX, dZ);
    }

    void Start()
    {
        transform.localScale = new Vector3(size, size, size);
        this.position = transform.position;
    }

    public List<Hexagon> GetNeighbors(bool isOffsetRight = true)
    {
        List<Hexagon> result = new List<Hexagon>();

        int offset = isOffsetRight ? 1 : -1;
        bool isEven = (z & 1) == 0;

        // Direct neighbors
        Hexagon neighbor = HexagonGrid.Instance.GetHexagon(x + offset, z);
        if (neighbor != null)
        {
            float movementCost = AStar.GetMovementCost(this, neighbor);
            if (character != null && movementCost <= character.currentActionPoints)
            {
                neighbor.character = character;
                neighbor.character.currentActionPoints -= (int)movementCost;
                neighbor.isWalkable = false;
                result.Add(neighbor);
            }
            else if (character == null && neighbor.isWalkable)
            {
                result.Add(neighbor);
            }
        }

        neighbor = HexagonGrid.Instance.GetHexagon(x - offset, z);
        if (neighbor != null)
        {
            float movementCost = AStar.GetMovementCost(this, neighbor);
            if (character != null && movementCost <= character.currentActionPoints)
            {
                neighbor.character = character;
                neighbor.character.currentActionPoints -= (int)movementCost;
                neighbor.isWalkable = false;
                result.Add(neighbor);
            }
            else if (character == null && neighbor.isWalkable)
            {
                result.Add(neighbor);
            }
        }

        neighbor = HexagonGrid.Instance.GetHexagon(x, z + 1);
        if (neighbor != null)
        {
            float movementCost = AStar.GetMovementCost(this, neighbor);
            if (character != null && movementCost <= character.currentActionPoints)
            {
                neighbor.character = character;
                neighbor.character.currentActionPoints -= (int)movementCost;
                neighbor.isWalkable = false;
                result.Add(neighbor);
            }
            else if (character == null && neighbor.isWalkable)
            {
                result.Add(neighbor);
            }
        }

        neighbor = HexagonGrid.Instance.GetHexagon(x, z - 1);
        if (neighbor != null)
        {
            float movementCost = AStar.GetMovementCost(this, neighbor);
            if (character != null && movementCost <= character.currentActionPoints)
            {
                neighbor.character = character;
                neighbor.character.currentActionPoints -= (int)movementCost;
                neighbor.isWalkable = false;
                result.Add(neighbor);
            }
            else if (character == null && neighbor.isWalkable)
            {
                result.Add(neighbor);
            }
        }

        // Diagonal neighbors
        if (isEven)
        {
            neighbor = HexagonGrid.Instance.GetHexagon(x - 1, z + 1);
            if (neighbor != null)
            {
                float movementCost = AStar.GetMovementCost(this, neighbor);
                if (character != null && movementCost <= character.currentActionPoints)
                {
                    neighbor.character = character;
                    neighbor.character.currentActionPoints -= (int)movementCost;
                    neighbor.isWalkable = false;
                    result.Add(neighbor);
                }
                else if (character == null && neighbor.isWalkable)
                {
                    result.Add(neighbor);
                }
            }

            neighbor = HexagonGrid.Instance.GetHexagon(x + 1, z + 1);
            if (neighbor != null)
            {
                float movementCost = AStar.GetMovementCost(this, neighbor);
                if (character != null && movementCost <= character.currentActionPoints)
                {
                    neighbor.character = character;
                    neighbor.character.currentActionPoints -= (int)movementCost;
                    neighbor.isWalkable = false;
                    result.Add(neighbor);
                }
                else if (character == null && neighbor.isWalkable)
                {
                    result.Add(neighbor);
                }
            }
        }
        else
        {
            neighbor = HexagonGrid.Instance.GetHexagon(x - 1, z - 1);
            if (neighbor != null)
            {
                float movementCost = AStar.GetMovementCost(this, neighbor);
                if (character != null && movementCost <= character.currentActionPoints)
                {
                    neighbor.character = character;
                    neighbor.character.currentActionPoints -= (int)movementCost;
                    neighbor.isWalkable = false;
                    result.Add(neighbor);
                }
                else if (character == null && neighbor.isWalkable)
                {
                    result.Add(neighbor);
                }
            }

            neighbor = HexagonGrid.Instance.GetHexagon(x + 1, z - 1);
            if (neighbor != null)
            {
                float movementCost = AStar.GetMovementCost(this, neighbor);
                if (character != null && movementCost <= character.currentActionPoints)
                {
                    neighbor.character = character;
                    neighbor.character.currentActionPoints -= (int)movementCost;
                    neighbor.isWalkable = false;
                    result.Add(neighbor);
                }
                else if (character == null && neighbor.isWalkable)
                {
                    result.Add(neighbor);
                }
            }
        }

        return result;
    }

        public void CharacterMovedOff()
    {
        character = null;
    }
}
    
....
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class HexagonGrid : MonoBehaviour
{
    public GameObject[] hexagonPrefabs;

    public int gridSizeX;
    public int gridSizeZ;
    public float xPosOffset = 1.5f;
    public float zPosOffset = 1.5f;
    public float size = 1.0f;

    private Hexagon[,] hexagons;

    public static HexagonGrid Instance { get; private set; }
    private void Awake()
    {
        // Set the instance to the current object
        Instance = this;


        hexagons = GenerateGrid();
    }
void Start()
    {
        //hexagons = GenerateGrid();
    }
    public Hexagon[,] GenerateGrid()
    {
        Hexagon[,] hexagons = new Hexagon[gridSizeX, gridSizeZ];
        float hexagonRadius = hexagonPrefabs[0].GetComponent<Renderer>().bounds.size.x / 2f;

        // Define a set of rules for walkability
        bool[,] walkable = new bool[gridSizeX, gridSizeZ];
        Debug.Log("Generating grid...");
        for (int z = 0; z < gridSizeZ; z++)
        {
            for (int x = 0; x < gridSizeX; x++)
            {
                // Set walkable to false for hexagons in the last row along the top and bottom edges
                if (z == 0 || z == gridSizeZ - 1)
                {
                    walkable[x, z] = false;
                }
                // Set walkable to false for hexagons in the last column along the left and right edges
                else if (x == 0 || x == gridSizeX - 1)
                {
                    walkable[x, z] = false;
                }
                // Set walkable to true for all other hexagons
                else
                {
                    walkable[x, z] = true;
                }
            }
        }


        for (int z = 0; z < gridSizeZ; z++)
        {
            for (int x = 0; x < gridSizeX; x++)
            {
                Vector3 position;
                if (z % 2 == 0)
                {
                    position = new Vector3(x * (2f * hexagonRadius), 0f, z * (1.5f * hexagonRadius));
                }
                else
                {
                    position = new Vector3((x + 0.5f) * (2f * hexagonRadius), 0f, z * (1.5f * hexagonRadius));
                }

                // Determine the walkability of the hexagon based on the rules
                bool isWalkable = walkable[x, z];

                GameObject hexagonPrefab = hexagonPrefabs[Random.Range(0, hexagonPrefabs.Length)];
                GameObject hexagonGO = Instantiate(hexagonPrefab, position, Quaternion.identity) as GameObject;
                hexagonGO.transform.localScale = new Vector3(size, size, size);

                Hexagon hexagon = hexagonGO.GetComponent<Hexagon>();
                hexagon.x = x;
                hexagon.z = z;
                hexagon.isWalkable = isWalkable;

                hexagons[x, z] = hexagon;
            }
        }
        Debug.Log("Grid generation complete.");
        return hexagons; 

    }




    public Hexagon GetHexagon(int x, int z)
    {
        if (x >= 0 && x < gridSizeX && z >= 0 && z < gridSizeZ)
        {
            return hexagons[x, z];
        }
        else
        {
            return null;
        }
    }
    public List<Hexagon> GetNeighbours(Hexagon hexagon)
    {
        List<Hexagon> neighbours = new List<Hexagon>();

        int x = hexagon.x;
        int z = hexagon.z;

        // Check direct neighbours
        if (x > 0)
        {
            neighbours.Add(hexagons[x - 1, z]);
        }

        if (x < gridSizeX - 1)
        {
            neighbours.Add(hexagons[x + 1, z]);
        }

        if (z > 0)
        {
            neighbours.Add(hexagons[x, z - 1]);

            if (x > 0)
            {
                neighbours.Add(hexagons[x - 1, z - 1]);
            }

            if (x < gridSizeX - 1)
            {
                neighbours.Add(hexagons[x + 1, z - 1]);
            }
        }

        if (z < gridSizeZ - 1)
        {
            neighbours.Add(hexagons[x, z + 1]);

            if (x > 0)
            {
                neighbours.Add(hexagons[x - 1, z + 1]);
            }

            if (x < gridSizeX - 1)
            {
                neighbours.Add(hexagons[x + 1, z + 1]);
            }
        }

        // Ensure that the neighbors' neighbors also include the current hexagon
        foreach (Hexagon neighbour in neighbours)
        {
            if (!neighbour.neighbors.Contains(hexagon))
            {
                neighbour.neighbors.Add(hexagon);
            }
        }

        return neighbours;
    }



    void OnDrawGizmos()
    {
        Gizmos.color = Color.black;

        for (int x = 0; x < gridSizeX; x++)
        {
            for (int z = 0; z < gridSizeZ; z++)
            {
                float xPos = x * xPosOffset;

                if (z % 2 == 1)
                {
                    xPos += xPosOffset / 2f;
                }

                Gizmos.DrawWireSphere(new Vector3(xPos, 0, z * zPosOffset), 0.25f);
            }
        }
    }
    public Hexagon GetHexagonAt(Vector3 position)
    {
        float q = (Mathf.Sqrt(3f) / 3f * position.x - 1f / 3f * position.z) / size;
        float r = (2f / 3f * position.z) / size;
        float x = q;
        float z = -x - r;
        int ix = Mathf.RoundToInt(x);
        int iz = Mathf.RoundToInt(z);
        return GetHexagon(ix, iz);
    }
}
....
using System.Collections.Generic;
using UnityEngine;
using System.Linq;

public class TurnManager : MonoBehaviour
{
    public List<Character> characters = new List<Character>();
    public int currentCharacterIndex = 0;
    private bool isCharacterMoving = false;
    public static TurnManager instance;


    private void Start()
    {
        SortCharactersByInitiative();
        StartNextCharacterTurn();
    }

    private void SortCharactersByInitiative()
    {
        List<Character> players = new List<Character>();
        foreach (GameObject obj in GameObject.FindGameObjectsWithTag("Player"))
        {
            Character player = obj.GetComponent<Character>();
            if (player != null)
            {
                players.Add(player);
            }
        }

        // Sort players by agility (and randomly break ties)
        players.Sort((a, b) => {
            if (a.agility != b.agility)
            {
                return b.agility.CompareTo(a.agility); // Sort by agility (highest to lowest)
            }
            else
            {
                return Random.Range(0, 2) == 0 ? -1 : 1; // Randomly break ties
            }
        });

        // Allocate index to each character based on the sorted initiative
        for (int i = 0; i < players.Count; i++)
        {
            players[i].currentIndex = i;
        }

        characters.Clear();
        characters.AddRange(players);

        Debug.Log("Characters sorted by initiative: " + string.Join(", ", characters.Select(c => c.characterName).ToArray()));
    }
    private void StartNextCharacterTurn()
    {
        if (currentCharacterIndex >= characters.Count)
        {
            // No more characters, end turn
            EndTurn();
            return;
        }

        Character currentCharacter = GetCurrentCharacter();
        currentCharacter.currentActionPoints = currentCharacter.maxActionPoints;
        Debug.Log("It's " + currentCharacter.name + "'s turn.");

        // Increment the currentCharacterIndex field
        currentCharacterIndex++;
    }


    private void EndTurn()
    {
        Debug.Log("End of turn.");
        currentCharacterIndex = 0;
        SortCharactersByInitiative();
        StartNextCharacterTurn();
    }

    public Character GetCurrentCharacter()
    {
        return currentCharacterIndex < characters.Count ? characters[currentCharacterIndex] : null;
    }

    public void MoveCurrentCharacterToHexagon(Hexagon hexagon)
    {
        Character currentCharacter = GetCurrentCharacter();
        if (currentCharacter == null)
        {
            Debug.LogError("No current character found");
            return;
        }

        int moveCost = Mathf.RoundToInt(Vector3.Distance(currentCharacter.transform.position, hexagon.transform.position) / hexagon.size) * 2;
        if (currentCharacter.currentActionPoints >= moveCost)
        {
            Debug.Log(currentCharacter.name + " moved to hexagon " + hexagon.Index);
            isCharacterMoving = true;
            currentCharacter.MoveToHexagon(hexagon); // Call MoveToHexagon method in Character script
            currentCharacter.currentActionPoints -= moveCost; // Remove action points from current character
            Debug.Log(currentCharacter.name + " has " + currentCharacter.currentActionPoints + " action points remaining.");
        }
        else
        {
            Debug.LogWarning(currentCharacter.name + " does not have enough action points to move to hexagon " + hexagon.Index);
        }
    }

    public void SetIsCharacterMoving(bool value)
    {
        isCharacterMoving = value;
    }

    public void EndCurrentCharacterTurn()
    {
        Character currentCharacter = GetCurrentCharacter();
        if (currentCharacter != null)
        {
            if (isCharacterMoving)
            {
                // If the current character is still moving, wait for it to finish before ending the turn
                return;
            }
            else
            {
                // End turn for current character
                currentCharacter.isCurrentTurn = false; // Set current character's turn flag to false
                currentCharacterIndex++;

                // Check if any characters are still able to move this turn
                bool canMove = false;
                for (int i = currentCharacterIndex; i < characters.Count; i++)
                {
                    if (characters[i].currentActionPoints > 0)
                    {
                        canMove = true;
                        break;
                    }
                }

                if (canMove)
                {
                    StartNextCharacterTurn();
                }
                else
                {
                    // No more characters can move this turn, end turn
                    EndTurn();
                }
            }
        }
    }

    void Update()
    {
        Character currentCharacter = GetCurrentCharacter();
        if (currentCharacter != null && !isCharacterMoving)
        {
            // Check if the current character has run out of action points
            if (currentCharacter.currentActionPoints == 0)
            {
                EndCurrentCharacterTurn();
            }
        }
        {
            if (Input.GetKeyDown(KeyCode.Return))
            {
                EndTurn();
            }
        }
    }
}
